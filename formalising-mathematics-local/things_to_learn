rintro -> like intro but then can do cases on something in one step
ext -> prove something by extensionality (e.g. equality of functions)
use cases to close the goal when there are no cases.

try -> tries to apply a tactic in brackets repeatedly but succeeds regardless.

we can use let instead of specialize:
  let ha := ha ε hε,

^ experiment with that one

We can do library search in standalone lemmas and then apply the found functions
in our proofs.

use cases with

look at conv mode

In the project comment a lot in the lemmas and if something follows from them
then write it in a concise way.

-> use nth_rewrite to rewrite only one occurrence of a specific pattern.

induction is done by splitting the goal into the base case and the inductive step.

Using set instead of let gives us the definition as well as the proposition that
the thing that we have defined is equal to the expression of its definition.

Conv mode allows for allows for going into complicated expressions and
'manually rewriting' the terms to obtain the form that we want.

You can apply with underscores to skip passing in arguments and turn them into goals

you can use apply_fun tactic to apply a function to both sides of an expression.

look up rfl tactic

rwa -> rewrite and try to use the assumption tactic.

avoid using complex proofs inside of let clauses.

for unfolding definitions use unfold tactic

omega does arithmetic
